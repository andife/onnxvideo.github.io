<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>https://andife.github.io/</title><link href="/" rel="alternate"></link><link href="/feeds/event_codedive-2019.atom.xml" rel="self"></link><id>/</id><updated>2019-11-20T00:00:00+00:00</updated><entry><title>AsyncIO and Music</title><link href="/codedive-2019/asyncio-and-music.html" rel="alternate"></link><published>2019-11-20T00:00:00+00:00</published><updated>2019-11-20T00:00:00+00:00</updated><author><name>Łukasz Langa</name></author><id>tag:,2019-11-20:codedive-2019/asyncio-and-music.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Can Python help a musician play hardware instruments? Is there anything specific about AsyncIO that makes it well suited to the task? Come see how AsyncIO can be used to aid music production and realtime performance through MIDI processing.&lt;/p&gt;
&lt;p&gt;First, we will cover the transformations of the incoming MIDI signal, that is helping the musician play his hardware instruments in new, unique ways. Examples of such transformations we will cover are arpeggiators, MIDI channel multiplexers, legato-based portamento.&lt;/p&gt;
&lt;p&gt;Then we'll move onto generative music, that is sequences generated procedurally. The musician specifies the tempo and the music scale, and a Python program generates music progressions on its own.&lt;/p&gt;
&lt;p&gt;We'll close with some thoughts on audio signal processing and the challenges faced there.&lt;/p&gt;
</summary></entry><entry><title>When Python Practices Go Wrong</title><link href="/codedive-2019/when-python-practices-go-wrong.html" rel="alternate"></link><published>2019-11-20T00:00:00+00:00</published><updated>2019-11-20T00:00:00+00:00</updated><author><name>Brandon Rhodes</name></author><id>tag:,2019-11-20:codedive-2019/when-python-practices-go-wrong.html</id><summary type="html">&lt;h3&gt;Description&lt;/h3&gt;&lt;p&gt;Just because a programming pattern or convention becomes popular doesn’t always mean it’s a good idea! Let’s dig into the consensus the Python community has built around what constitutes “Pythonic” code and look at the cases where the conventional wisdom is wrong. In the process, we’ll learn how code in a dynamic language can become more readable and more effective.&lt;/p&gt;
</summary></entry></feed>